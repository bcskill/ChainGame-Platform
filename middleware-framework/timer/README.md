Kafka time wheel

There are many delayed operations in Kafka, such as delayed production, delayed pull and delayed delete. Kafka does not use the timer or delayqueue provided by JDK to implement the delay function, but based on the time wheel, it has customized a timer (system timer) to implement the delay function. The average time complexity of insertion and deletion of timer and delayqueue in JDK is O (NLog (n)), which can not meet Kafka's high performance requirements. Based on the time wheel, the time complexity of insertion and deletion can be reduced to o (1). The application of time wheel is not unique to Kafka. There are many application scenarios. There are traces of time wheel in netty, akka, quartz, zookeeper and other components.

Kafka time wheel is composed of several time grids, each of which represents the basic time span (tickms) of the current time wheel. The number of time cells of the time wheel is fixed, which can be expressed by wheelsize. Then the total time span (interval) of the whole time wheel can be calculated by the formula tickms Ã— wheelsize. The time wheel also has a dial pointer (currenttime), which is used to represent the current time of the time wheel. Currenttime is an integer multiple of tickms. Currenttime can divide the whole time round into the due part and the unexpired part. The current time points to a time bucket that also belongs to the due part, which means it just expires. All tasks of the timertasklist corresponding to this time bucket need to be processed.

If tickms = 1ms and wheelsize = 20 of the time wheel, it can be calculated that the interval is 20ms. Initially, the dial pointer currenttime points to time slot 0. At this time, a task with a timing of 2ms will be inserted and stored in the timertasklist with a time slot of 2. As time goes on, the pointer currenttime keeps moving forward. After 2ms, when it reaches time slot 2, it needs to perform the corresponding expiration operation for the tasks in the time task list corresponding to time slot 2. At this time, if another task with a timing of 8ms is inserted, it will be stored in time slot 10, and the current time will point to time slot 10 after 8ms. What if there is a task scheduled for 19ms inserted at the same time? The new timertaskentry will reuse the original timertasklist, so it will be inserted into the time slot 1 that has already expired. In a word, the overall span of the whole time wheel is constant. With the continuous advancement of the pointer currenttime, the time period that the current time wheel can handle is also constantly moving backward, and the overall time range is between currenttime and currenttime + interval.

What if there is a task scheduled for 350ms? Expand the size of wheelsize directly? There are tens of thousands or even hundreds of thousands of milliseconds of timing tasks in Kafka. There is no bottom line for the expansion of this wheelsize. Even if the expiration time of all timing tasks is set to a upper limit, such as 1 million milliseconds, then the wheel with a wheelsize of 1 million milliseconds will not only occupy a lot of memory space, but also reduce the efficiency. Kafka introduces the concept of hierarchical time wheel for this purpose. When the task's expiration time exceeds the time range represented by the current time wheel, it will try to add it to the upper time wheel.
